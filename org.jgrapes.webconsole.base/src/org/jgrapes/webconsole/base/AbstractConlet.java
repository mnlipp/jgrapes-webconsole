/*
 * JGrapes Event Driven Framework
 * Copyright (C) 2017-2022 Michael N. Lipp
 * 
 * This program is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Affero General Public License as published by 
 * the Free Software Foundation; either version 3 of the License, or 
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License 
 * for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License along 
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 */

package org.jgrapes.webconsole.base;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringWriter;
import java.net.URL;
import java.nio.CharBuffer;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.UUID;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import org.jgrapes.core.Channel;
import org.jgrapes.core.Component;
import org.jgrapes.core.Components;
import org.jgrapes.core.Components.Timer;
import org.jgrapes.core.Event;
import org.jgrapes.core.annotation.Handler;
import org.jgrapes.core.annotation.HandlerDefinition.ChannelReplacements;
import org.jgrapes.core.events.Detached;
import org.jgrapes.http.Session;
import org.jgrapes.io.IOSubchannel;
import org.jgrapes.io.events.Closed;
import org.jgrapes.webconsole.base.Conlet.RenderMode;
import org.jgrapes.webconsole.base.events.AddConletRequest;
import org.jgrapes.webconsole.base.events.AddConletType;
import org.jgrapes.webconsole.base.events.ConletDeleted;
import org.jgrapes.webconsole.base.events.ConletResourceRequest;
import org.jgrapes.webconsole.base.events.ConsoleReady;
import org.jgrapes.webconsole.base.events.DeleteConlet;
import org.jgrapes.webconsole.base.events.NotifyConletModel;
import org.jgrapes.webconsole.base.events.NotifyConletView;
import org.jgrapes.webconsole.base.events.RemoveConletType;
import org.jgrapes.webconsole.base.events.RenderConlet;
import org.jgrapes.webconsole.base.events.RenderConletRequest;
import org.jgrapes.webconsole.base.events.RenderConletRequestBase;
import org.jgrapes.webconsole.base.events.SetLocale;

/**
 * Provides a base class for implementing web console components.
 * The class provides the following support functions:
 *  * "Translate" the conlet related events to invocations
 *    of abstract methods. This is mainly a prerequisite
 *    for implementing the other support functions.
 *  * Optionally manage state for a conlet instance.
 *  * Optionally track the existing previews or views of
 *    a conlet, thus allowing the server side to send update
 *    events (usually when the state changes on the server side).
 *  * Optionally refresh existing previews or views periodically
 * 
 * # Event handling
 * 
 * The following diagrams show the events exchanged between
 * the {@link WebConsole} and a web console component from the 
 * web console component's perspective. If applicable, they also show 
 * how the events are translated by the {@link AbstractConlet} to invocations 
 * of the abstract methods that have to be implemented by the
 * derived class (the web console component that provides
 * a specific web console component type).
 * 
 * ## ConsoleReady
 * 
 * ![Add web console component type handling](AddConletTypeHandling.svg)
 * 
 * From the web console's page point of view, a web console component 
 * consists of CSS and JavaScript that is added to the console page by
 * {@link AddConletType} events and HTML that is provided by 
 * {@link RenderConlet} events (see below). These events must 
 * therefore be generated by a web console component. 
 * 
 * The {@link AbstractConlet} does not provide support for generating 
 * an {@link AddConletType} event. The handler for the 
 * {@link ConsoleReady} that generates this event must be implemented by
 * the derived class itself.
 * 
 * ## AddConletRequest
 * 
 * ![Add web console component handling](AddConletHandling.svg)
 * 
 * The {@link AddConletRequest} indicates that a new web console component
 * instance of a given type should be added to the page. The
 * {@link AbstractConlet} checks the type requested, and if
 * it matches, invokes {@link #generateInstanceId generateInstanceId}
 * and{@link #createNewState createNewState}.
 * If the conlet has associated state, the information is saved with
 * {@link #putInSession putInSession}. Then 
 * {@link #doRenderConlet doRenderConlet} is invoked, which must 
 * render the conlet in the browser. Information about the rendered views
 * is returned and used to track the views.
 * 
 * Method {@link #doRenderConlet doRenderConlet} renders the preview 
 * or view by firing a {@link RenderConlet} event that provides to 
 * the console session the HTML that represents the web console 
 * component on the page. The HTML may be generated using and thus 
 * depending on the component state.
 * Alternatively, state independent HTML may be provided followed 
 * by a {@link NotifyConletView} event that updates
 * the HTML (using JavaScript) on the console page. The latter approach
 * is preferred if the model changes frequently and updating the
 * rendered representation is more efficient than providing a new one.
 * 
 * ## RenderConletRequest
 * 
 * ![Render web console component handling](RenderConletHandling.svg)
 * 
 * A {@link RenderConletRequest} event indicates that the web console page
 * needs the HTML for displaying a web console component. This may be caused
 * by e.g. the initial display, by a refresh or by requesting a full 
 * page view from the preview.
 * 
 * Upon receiving such an event, the {@link AbstractConlet}
 * checks if it has state information for the component id
 * requested. If not, it calls {@link #recreateState recreateState} 
 * which allows the conlet to e.g. retrieve state information from
 * a backing store.
 * 
 * Once state information has been obtained, the method 
 * invokes as when adding a new conlet by invoking
 * {@link #doRenderConlet doRenderConlet}.
 * 
 * ## ConletDeleted
 * 
 * ![Web console component deleted handling](ConletDeletedHandling.svg)
 * 
 * When the {@link AbstractConlet} receives a {@link ConletDeleted},
 * it updates the information about the shown conlet views. If the
 * conlet is no longer used in the browser (no views remain),
 * it deletes the state information from the session. In any case, it
 * invokes {@link #doConletDeleted doConletDeleted} with the 
 * state information.
 * 
 * ## NotifyConletModel
 * 
 * ![Notify web console component model handling](NotifyConletModelHandling.svg)
 * 
 * If the web console component views include input elements, actions 
 * on these elements may result in {@link NotifyConletModel} events from
 * the web console page to the web console. When the {@link AbstractConlet}
 * receives such events, it retrieves any existing state information. 
 * It then invokes {@link #doUpdateConletState doUpdateConletState} with the
 * retrieved information. The web console component usually responds with
 * a {@link NotifyConletView} event. However, it can also
 * re-render the complete conlet view.
 * 
 * Support for unsolicited updates
 * -------------------------------
 * 
 * The class tracks the relationship between the known
 * {@link ConsoleSession}s and the web console components displayed 
 * in these console session. The information is available from
 * {@link #conletInfosByConsoleSession}. It can e.g. be used to send
 * events to the web console(s) in response to an event on the server
 * side.
 *
 * @param <S> the type of the conlet's state information
 * 
 * @startuml AddConletTypeHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> Conlet: ConsoleReady
 * deactivate WebConsole
 * activate Conlet
 * Conlet -> WebConsole: AddConletType 
 * deactivate Conlet
 * activate WebConsole
 * deactivate WebConsole
 * @enduml
 * 
 * @startuml AddConletHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> Conlet: AddConletRequest
 * deactivate WebConsole
 * activate Conlet
 * Conlet -> Conlet: generateInstanceId
 * activate Conlet
 * deactivate Conlet
 * Conlet -> Conlet: createNewState
 * activate Conlet
 * deactivate Conlet
 * opt if state
 *     Conlet -> Conlet: putInSession
 *     activate Conlet
 *     deactivate Conlet
 * end opt
 * Conlet -> Conlet: doRenderConlet
 * activate Conlet
 * Conlet -> WebConsole: RenderConlet
 * activate WebConsole
 * deactivate WebConsole
 * opt
 *     Conlet -> WebConsole: NotifyConletView
 *     activate WebConsole
 *     deactivate WebConsole
 * end opt
 * deactivate Conlet
 * Conlet -> Conlet: start conlet tracking
 * @enduml
 * 
 * @startuml RenderConletHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> Conlet: RenderConletRequest
 * deactivate WebConsole
 * activate Conlet
 * Conlet -> Conlet: stateFromSession
 * activate Conlet
 * deactivate Conlet
 * opt if not found
 *     Conlet -> Conlet: recreateState
 *     activate Conlet
 *     deactivate Conlet
 * end opt
 * Conlet -> Conlet: doRenderConlet
 * activate Conlet
 * Conlet -> WebConsole: RenderConlet 
 * activate WebConsole
 * deactivate WebConsole
 * opt 
 *     Conlet -> WebConsole: NotifyConletView
 * activate WebConsole
 * deactivate WebConsole
 * end opt 
 * deactivate Conlet
 * Conlet -> Conlet: update conlet tracking
 * @enduml
 * 
 * @startuml NotifyConletModelHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> Conlet: NotifyConletModel
 * deactivate WebConsole
 * activate Conlet
 * Conlet -> Conlet: stateFromSession
 * activate Conlet
 * deactivate Conlet
 * Conlet -> Conlet: doUpdateConletState
 * activate Conlet
 * opt
 *     Conlet -> WebConsole: RenderConlet
 * end opt 
 * opt 
 *     Conlet -> WebConsole: NotifyConletView
 * end opt 
 * deactivate Conlet
 * deactivate Conlet
 * @enduml
 * 
 * @startuml ConletDeletedHandling.svg
 * hide footbox
 * 
 * activate WebConsole
 * WebConsole -> Conlet: ConletDeleted
 * deactivate WebConsole
 * activate Conlet
 * Conlet -> Conlet: stateFromSession
 * activate Conlet
 * deactivate Conlet
 * alt all views deleted
 *     Conlet -> Conlet: removeState
 *     activate Conlet
 *     deactivate Conlet
 *     Conlet -> Conlet: stop conlet tracking
 * else
 *     Conlet -> Conlet: update conlet tracking
 * end alt
 * Conlet -> Conlet: doConletDeleted
 * activate Conlet
 * deactivate Conlet
 * deactivate Conlet
 * @enduml
 */
@SuppressWarnings({ "PMD.TooManyMethods",
    "PMD.EmptyMethodInAbstractClassShouldBeAbstract", "PMD.GodClass",
    "PMD.ExcessiveImports" })
public abstract class AbstractConlet<S extends Serializable>
        extends Component {

    @SuppressWarnings({ "PMD.FieldNamingConventions",
        "PMD.VariableNamingConventions", "PMD.UseConcurrentHashMap",
        "PMD.AvoidDuplicateLiterals" })
    private static final Map<Class<?>,
            Map<Locale, ResourceBundle>> supportedLocales
                = Collections.synchronizedMap(new WeakHashMap<>());
    @SuppressWarnings({ "PMD.FieldNamingConventions",
        "PMD.VariableNamingConventions", "PMD.UseConcurrentHashMap" })
    private static final Map<Class<?>,
            Map<Locale, ResourceBundle>> l10nBundles
                = Collections.synchronizedMap(new WeakHashMap<>());
    @SuppressWarnings("PMD.LongVariable")
    private Map<ConsoleSession,
            Map<String, ConletTrackingInfo>> conletInfosByConsoleSession;
    private Duration refreshInterval;
    private Supplier<Event<?>> refreshEventSupplier;
    private Timer refreshTimer;

    /**
     * Creates a new component that listens for new events
     * on the given channel.
     * 
     * @param channel the channel to listen on
     */
    public AbstractConlet(Channel channel) {
        this(channel, null);
    }

    /**
     * Like {@link #AbstractConlet(Channel)}, but supports
     * the specification of channel replacements.
     *
     * @param channel the channel to listen on
     * @param channelReplacements the channel replacements (see
     * {@link Component})
     */
    public AbstractConlet(Channel channel,
            ChannelReplacements channelReplacements) {
        super(channel, channelReplacements);
        conletInfosByConsoleSession
            = Collections.synchronizedMap(new WeakHashMap<>());
    }

    /**
     * If set to a value different from `null` causes an event
     * from the given supplier to be fired on all tracked web console
     * sessions periodically.
     *
     * @param interval the refresh interval
     * @param supplier the supplier
     * @return the web console component for easy chaining
     */
    @SuppressWarnings("PMD.LinguisticNaming")
    public AbstractConlet<S> setPeriodicRefresh(
            Duration interval, Supplier<Event<?>> supplier) {
        refreshInterval = interval;
        refreshEventSupplier = supplier;
        if (refreshTimer != null) {
            refreshTimer.cancel();
            refreshTimer = null;
        }
        updateRefresh();
        return this;
    }

    private void updateRefresh() {
        if (refreshInterval == null || conletIdsByConsoleSession().isEmpty()) {
            // At least one of the prerequisites is missing, terminate
            if (refreshTimer != null) {
                refreshTimer.cancel();
                refreshTimer = null;
            }
            return;
        }
        if (refreshTimer != null) {
            // Already running.
            return;
        }
        refreshTimer = Components.schedule(tmr -> {
            tmr.reschedule(tmr.scheduledFor().plus(refreshInterval));
            fire(refreshEventSupplier.get(), trackedSessions());
        }, Instant.now().plus(refreshInterval));
    }

    /**
     * Returns the web console component type. The default implementation
     * returns the name of the class.
     * 
     * @return the type
     */
    protected String type() {
        return getClass().getName();
    }

    /**
     * A default handler for resource requests. Checks that the request
     * is directed at this web console component, and calls 
     * {@link #doGetResource}.
     * 
     * @param event the resource request event
     * @param channel the channel that the request was recived on
     */
    @Handler
    public final void onConletResourceRequest(
            ConletResourceRequest event, IOSubchannel channel) {
        // For me?
        if (!event.conletClass().equals(type())) {
            return;
        }
        doGetResource(event, channel);
    }

    /**
     * The default implementation searches for a file with the 
     * requested resource URI in the web console component's class 
     * path and sets its {@link URL} as result if found.
     * 
     * @param event the event. The result will be set to
     * `true` on success
     * @param channel the channel
     */
    protected void doGetResource(ConletResourceRequest event,
            IOSubchannel channel) {
        URL resourceUrl = this.getClass().getResource(
            event.resourceUri().getPath());
        if (resourceUrl == null) {
            return;
        }
        event.setResult(new ResourceByUrl(event, resourceUrl));
        event.stop();
    }

    /**
     * Provides a resource bundle for localization.
     * The default implementation looks up a bundle using the
     * package name plus "l10n" as base name. Note that the bundle 
     * returned for a given locale may be the fallback bundle.
     * 
     * @return the resource bundle
     */
    protected ResourceBundle resourceBundle(Locale locale) {
        return ResourceBundle.getBundle(
            getClass().getPackage().getName() + ".l10n", locale,
            getClass().getClassLoader(),
            ResourceBundle.Control.getNoFallbackControl(
                ResourceBundle.Control.FORMAT_DEFAULT));
    }

    /**
     * Returns bundles for the given locales. 
     * 
     * The default implementation uses {@link #resourceBundle(Locale)} 
     * to lookup the bundles. The method is guaranteed to return a 
     * bundle for each requested locale even if it is only the fallback 
     * bundle. The evaluated results are cached for the conlet class.
     *
     * @param toGet the locales to get bundles for
     * @return the map with locales and bundles
     */
    @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
    protected Map<Locale, ResourceBundle> l10nBundles(Set<Locale> toGet) {
        @SuppressWarnings("PMD.UseConcurrentHashMap")
        Map<Locale, ResourceBundle> result = new HashMap<>();
        for (Locale locale : toGet) {
            ResourceBundle bundle;
            synchronized (l10nBundles) {
                // Due to the nested computeIfAbsent, it is not sufficient
                // that l10nBundels is thread safe.
                bundle = l10nBundles
                    .computeIfAbsent(getClass(),
                        cls -> new ConcurrentHashMap<>())
                    .computeIfAbsent(locale, l -> resourceBundle(locale));
            }
            result.put(locale, bundle);
        }
        return Collections.unmodifiableMap(result);
    }

    /**
     * Provides localizations for the given key for all requested locales.
     * 
     * The default implementation uses {@link #l10nBundles(Set)} to obtain
     * the localizations.
     *
     * @param locales the requested locales
     * @param key the key
     * @return the result
     */
    protected Map<Locale, String> localizations(Set<Locale> locales,
            String key) {
        @SuppressWarnings("PMD.UseConcurrentHashMap")
        Map<Locale, String> result = new HashMap<>();
        Map<Locale, ResourceBundle> bundles = l10nBundles(locales);
        for (Map.Entry<Locale, ResourceBundle> entry : bundles.entrySet()) {
            result.put(entry.getKey(), entry.getValue().getString(key));
        }
        return result;
    }

    /**
     * Returns the supported locales and the associated bundles.
     * 
     * The default implementation invokes {@link #resourceBundle(Locale)}
     * with all available locales and drops results with fallback bundles.
     * The evaluated results are cached for the conlet class.
     *
     * @return the result
     */
    protected Map<Locale, ResourceBundle> supportedLocales() {
        return supportedLocales.computeIfAbsent(getClass(), cls -> {
            ResourceBundle.clearCache(cls.getClassLoader());
            @SuppressWarnings("PMD.UseConcurrentHashMap")
            Map<Locale, ResourceBundle> bundles = new HashMap<>();
            for (Locale locale : Locale.getAvailableLocales()) {
                if ("".equals(locale.getLanguage())) {
                    continue;
                }
                ResourceBundle bundle = resourceBundle(locale);
                if (bundle.getLocale().equals(locale)) {
                    bundles.put(locale, bundle);
                }
            }
            return bundles;
        });
    }

    /**
     * Create the instance specific part of a conlet id. The default
     * implementation generates a UUID. Derived classes override this
     * method if e.g. the instance specific part must include a key that
     * associates the conlet's state with some backing store. 
     * 
     * @param event the event that triggered the creation of a new conlet,
     * which may contain required information 
     * (see {@link AddConletRequest#properties()})
     * @param session the console session; usually not required 
     * but provided as context
     *
     * @return the web console component id
     */
    protected String generateInstanceId(AddConletRequest event,
            ConsoleSession session) {
        return UUID.randomUUID().toString();
    }

    /**
     * Creates an instance of the type that represents the conlet's state.
     * The default implementation returns {@link Optional#isEmpty()}, 
     * thus indicating that no state information is needed or available.
     *
     * @param event the event, which may contain required information 
     * (see {@link AddConletRequest#properties()})
     * @param session the console session, sometimes required to
     * send events to components that provide a backing store
     * @param conletId the conlet id calculated as
     * `type() + "~" + generateInstanceId(...)` 
     * @return the state representation or {@link Optional#empty()} if none is
     * required
     * @throws Exception if an exception occurs
     */
    @SuppressWarnings({ "PMD.SignatureDeclareThrowsException",
        "PMD.AvoidDuplicateLiterals" })
    protected Optional<S> createStateRepresentation(
            RenderConletRequestBase<?> event, ConsoleSession session,
            String conletId) throws Exception {
        return Optional.empty();
    }

    /**
     * Called by {@link #onAddConletRequest}
     * when a new conlet instance is created in the browser. The default
     * implementation simply invokes {@link 
     * #createStateRepresentation} and returns its result.
     *
     * @param event the event 
     * @param session the console session
     * @param conletId the conlet id
     * @return the state representation or {@link Optional#empty()} if none is
     * required
     * @throws Exception if an exception occurs
     */
    @SuppressWarnings({ "PMD.SignatureDeclareThrowsException",
        "PMD.AvoidDuplicateLiterals" })
    protected Optional<S> createNewState(
            AddConletRequest event, ConsoleSession session,
            String conletId) throws Exception {
        return createStateRepresentation(event, session, conletId);
    }

    /**
     * Called by {@link #onRenderConletRequest} when a previously 
     * created conlet is rendered in a new browser session
     * for the first time. The default implementation simply invokes {@link 
     * #createStateRepresentation} and returns its result.
     *
     * @param event the event 
     * @param session the console session
     * @param conletId the conlet id
     * @return the state representation or {@link Optional#empty()} if none is
     * required
     * @throws Exception if an exception occurs
     */
    @SuppressWarnings({ "PMD.SignatureDeclareThrowsException",
        "PMD.AvoidDuplicateLiterals" })
    protected Optional<S> recreateState(
            RenderConletRequest event, ConsoleSession session,
            String conletId) throws Exception {
        return createStateRepresentation(event, session, conletId);
    }

    /**
     * Returns the tracked sessions and conlet ids as map.
     * 
     * If you need a particular session's web console component ids, you 
     * should prefer {@link #conletIds(ConsoleSession)} over calling
     * this method with `get(consoleSession)` appended.
     * 
     * @return the result
     */
    protected Map<ConsoleSession, Set<String>> conletIdsByConsoleSession() {
        return conletInfosByConsoleSession.entrySet().stream()
            .collect(Collectors.toMap(Entry::getKey,
                e -> new HashSet<>(e.getValue().keySet())));
    }

    /**
     * Returns the tracked sessions. This is effectively
     * `conletInfosByConsoleSession().keySet()` converted to
     * an array. This representation is especially useful 
     * when the web console sessions are used as argument for 
     * {@link #fire(Event, Channel...)}.
     *
     * @return the web console sessions
     */
    protected ConsoleSession[] trackedSessions() {
        Set<ConsoleSession> sessions = new HashSet<>(
            conletInfosByConsoleSession.keySet());
        return sessions.toArray(new ConsoleSession[0]);
    }

    /**
     * Returns the set of web console component ids associated with the 
     * console session as a {@link Set}. If no web console components 
     * have registered yet, an empty set is returned.
     * 
     * @param consoleSession the console session
     * @return the set
     */
    protected Set<String> conletIds(ConsoleSession consoleSession) {
        return new HashSet<>(conletInfosByConsoleSession.getOrDefault(
            consoleSession, Collections.emptyMap()).keySet());
    }

    /**
     * Returns a map of all conlet ids and the modes in which 
     * views are currently rendered. 
     *
     * @param consoleSession the console session
     * @return the map
     */
    protected Map<String, Set<RenderMode>>
            conletViews(ConsoleSession consoleSession) {
        return conletInfosByConsoleSession.getOrDefault(
            consoleSession, Collections.emptyMap()).entrySet().stream()
            .collect(Collectors.toMap(e -> e.getKey(),
                e -> e.getValue().renderedAs));
    }

    /**
     * Track the given web console component from the given session. 
     * This is invoked by 
     * {@link #onAddConletRequest(AddConletRequest, ConsoleSession)} and
     * {@link #onRenderConletRequest(RenderConletRequest, ConsoleSession)}.
     * It needs only be invoked if either method is overridden.
     *
     * @param consoleSession the web console session
     * @param conletId the conlet id
     * @param info the info to be added if currently untracked. If `null`,
     * a new {@link ConletTrackingInfo} is created and added
     * @return the conlet tracking info
     */
    protected ConletTrackingInfo trackConlet(ConsoleSession consoleSession,
            String conletId, ConletTrackingInfo info) {
        ConletTrackingInfo result;
        synchronized (conletInfosByConsoleSession) {
            Map<String, ConletTrackingInfo> infos
                = conletInfosByConsoleSession.computeIfAbsent(consoleSession,
                    newKey -> new ConcurrentHashMap<>());
            result = infos.computeIfAbsent(conletId,
                key -> Optional.ofNullable(info)
                    .orElse(new ConletTrackingInfo(conletId)));
        }
        updateRefresh();
        return result;
    }

    /**
     * Helper that provides access to a storage space for this 
     * conlet type in the browser session.
     *
     * @param session the session
     * @return the map
     */
    private Map<String, S> typeContext(Session session) {
        synchronized (session) {
            @SuppressWarnings({ "unchecked", "PMD.AvoidDuplicateLiterals" })
            Map<String, Map<String, S>> abstractConletContext
                = (Map<String, Map<String, S>>) session
                    .computeIfAbsent(AbstractConlet.class,
                        k -> new ConcurrentHashMap<>());
            return abstractConletContext
                .computeIfAbsent(type(), k -> new ConcurrentHashMap<>());
        }
    }

    /**
     * Puts the given web console component state in the session using the 
     * {@link #type()} and the given web console component id as keys.
     * 
     * @param session the session to use
     * @param conletId the web console component id
     * @param conletState the web console component state
     * @return the component state
     */
    protected Serializable putInSession(Session session, String conletId,
            S conletState) {
        typeContext(session).put(conletId, conletState);
        return conletState;
    }

    /**
     * Returns the state of this web console component's type 
     * with the given id from the session.
     *
     * @param session the session to use
     * @param conletId the web console component id
     * @return the web console component state
     */
    protected Optional<S> stateFromSession(Session session, String conletId) {
        return Optional.ofNullable(typeContext(session).get(conletId));
    }

    /**
     * Returns all conlet ids and conlet states of this web console 
     * component's type from the session.
     *
     * @param session the console session
     * @return the states
     */
    protected Collection<Map.Entry<String, S>>
            statesFromSession(ConsoleSession session) {
        return typeContext(session.browserSession()).entrySet();
    }

    /**
     * Removes the web console component state of the 
     * web console component with the given id from the session. 
     * 
     * @param session the session to use
     * @param conletId the web console component id
     * @return the removed state if state existed
     */
    protected Optional<S> removeState(Session session, String conletId) {
        S state = typeContext(session).remove(conletId);
        return Optional.ofNullable(state);
    }

    /**
     * Checks if the request applies to this component. If so, stops the event,
     * creates a new conlet id (see {@link #generateInstanceId}) and 
     * new state information (see {@link #createNewState}). The state
     * is saved in the session (see {@link #putInSession}),
     * {@link #doRenderConlet} is called and its result is passed to
     * {@link #trackConlet}.
     *
     * @param event the event
     * @param consoleSession the channel
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings({ "PMD.SignatureDeclareThrowsException",
        "PMD.AvoidDuplicateLiterals" })
    public final void onAddConletRequest(AddConletRequest event,
            ConsoleSession consoleSession) throws Exception {
        if (!event.conletType().equals(type())) {
            return;
        }
        event.stop();
        String conletId
            = type() + "~" + generateInstanceId(event, consoleSession);
        Optional<S> state = createNewState(event, consoleSession, conletId);
        state.ifPresent(s -> putInSession(
            consoleSession.browserSession(), conletId, s));
        event.setResult(conletId);
        trackConlet(consoleSession, conletId, new ConletTrackingInfo(conletId)
            .addModes(doRenderConlet(event, consoleSession, conletId,
                state.orElse(null))));
    }

    /**
     * Checks if the request applies to this component. If so, stops 
     * the event. If the conlet is completely removed from the browser,
     * removes the web console component state from the 
     * browser session. In all cases, it calls {@link #doConletDeleted} 
     * with the state.
     * 
     * @param event the event
     * @param consoleSession the web console session
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    public final void onConletDeleted(ConletDeleted event,
            ConsoleSession consoleSession) throws Exception {
        if (!event.conletId().startsWith(type() + "~")) {
            return;
        }
        String conletId = event.conletId();
        Optional<S> model = stateFromSession(
            consoleSession.browserSession(), conletId);
        if (event.renderModes().isEmpty()) {
            removeState(consoleSession.browserSession(), conletId);
            for (Iterator<Entry<ConsoleSession, Map<String,
                    ConletTrackingInfo>>> csi = conletInfosByConsoleSession
                        .entrySet().iterator();
                    csi.hasNext();) {
                Map<String, ConletTrackingInfo> infos = csi.next().getValue();
                infos.remove(conletId);
                if (infos.isEmpty()) {
                    csi.remove();
                }
            }
            updateRefresh();
        } else {
            trackConlet(consoleSession, conletId, null)
                .removeModes(event.renderModes());
        }
        event.stop();
        doConletDeleted(event, consoleSession, event.conletId(),
            model.orElse(null));
    }

    /**
     * Called by {@link #onConletDeleted} to propagate the event to derived
     * classes.
     *
     * @param event the event
     * @param channel the channel
     * @param conletId the web console component id
     * @param conletState the conlet's state; may be `null` if the
     * conlet doesn't have associated state information
     * @throws Exception if a problem occurs
     */
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    protected void doConletDeleted(ConletDeleted event, ConsoleSession channel,
            String conletId, S conletState)
            throws Exception {
        // May be defined by derived class.
    }

    /**
     * Checks if the request applies to this component by verifying 
     * if the component id starts with {@link #type()} plus "~".
     * If the id matches, sets the event's result to `true`, stops the 
     * event and tries to retrieve the model from the session. If this
     * fails, {@link #recreateState} is called as another attempt to
     * obtain state information.
     *  
     * Finally, {@link #doRenderConlet} is called and the result is added
     * to the tracking information. 
     *
     * @param event the event
     * @param consoleSession the web console session
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    public final void onRenderConletRequest(RenderConletRequest event,
            ConsoleSession consoleSession) throws Exception {
        if (!event.conletId().startsWith(type() + "~")) {
            return;
        }
        Optional<S> state = stateFromSession(
            consoleSession.browserSession(), event.conletId());
        if (state.isEmpty()) {
            state = recreateState(event, consoleSession, event.conletId());
        }
        event.setResult(true);
        event.stop();
        Set<RenderMode> rendered = doRenderConlet(
            event, consoleSession, event.conletId(), state.orElse(null));
        trackConlet(consoleSession, event.conletId(), null).addModes(rendered);
    }

    /**
     * Called by 
     * {@link #onAddConletRequest(AddConletRequest, ConsoleSession)} and
     * {@link #onRenderConletRequest(RenderConletRequest, ConsoleSession)} 
     * to complete rendering the web console component.
     * 
     * The 
     *
     * @param event the event
     * @param channel the channel
     * @param conletId the component id
     * @param conletState the conlet's state; may be `null` if the
     * conlet doesn't have associated state information
     * @return the rendered modes
     * @throws Exception the exception
     */
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    protected abstract Set<RenderMode> doRenderConlet(
            RenderConletRequestBase<?> event, ConsoleSession channel,
            String conletId, S conletState)
            throws Exception;

    /**
     * Invokes {@link #doSetLocale(SetLocale, ConsoleSession, String)}
     * for each web console component in the console session.
     * 
     * If the vent has the reload flag set, does nothing.
     * 
     * The default implementation fires a 
     *
     * @param event the event
     * @param consoleSession the web console session
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    public void onSetLocale(SetLocale event, ConsoleSession consoleSession)
            throws Exception {
        if (event.reload()) {
            return;
        }
        for (String conletId : conletIds(consoleSession)) {
            if (!doSetLocale(event, consoleSession, conletId)) {
                event.forceReload();
                break;
            }
        }
    }

    /**
     * Called by {@link #onSetLocale(SetLocale, ConsoleSession)} for
     * each web console component in the console session. Derived 
     * classes must send events for updating the representation to 
     * match the new locale.
     * 
     * If the method returns `false` this indicates that the representation 
     * cannot be updated without reloading the web console page.
     * 
     * The default implementation fires a {@link RenderConletRequest}
     * with tracked render modes (one of or both {@link RenderMode#Preview}
     * and {@link RenderMode#View}), thus updating the known representations.
     * (Assuming that "Edit" and "Help" modes are represented with modal 
     * dialogs and therefore locale changes aren't possible while these are 
     * open.) 
     *
     * @param event the event
     * @param channel the channel
     * @param conletId the web console component id
     * @return true, if the locale could be changed
     * @throws Exception the exception
     */
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    protected boolean doSetLocale(SetLocale event, ConsoleSession channel,
            String conletId) throws Exception {
        fire(new RenderConletRequest(event.renderSupport(), conletId,
            trackConlet(channel, conletId, null).renderedAs()),
            channel);
        return true;
    }

    /**
     * If {@link #stateFromSession(Session, String)} returns a model,
     * calls {@link #doUpdateConletState} with the model. 
     *
     * @param event the event
     * @param channel the channel
     * @throws Exception the exception
     */
    @Handler
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    public final void onNotifyConletModel(NotifyConletModel event,
            ConsoleSession channel) throws Exception {
        if (!event.conletId().startsWith(type() + "~")) {
            return;
        }
        Optional<S> model
            = stateFromSession(channel.browserSession(), event.conletId());
        doUpdateConletState(event, channel, model.orElse(null));
    }

    /**
     * Called by {@link #onNotifyConletModel} to complete handling
     * the notification. The default implementation does nothing.
     * 
     * @param event the event
     * @param channel the channel
     * @param conletState the conlet's state; may be `null` if the
     * conlet doesn't have associated state information
     */
    @SuppressWarnings("PMD.SignatureDeclareThrowsException")
    protected void doUpdateConletState(NotifyConletModel event,
            ConsoleSession channel, S conletState) throws Exception {
        // Default is to do nothing.
    }

    /**
     * Removes the {@link ConsoleSession} from the set of tracked sessions.
     * If derived web console components need to perform extra actions when a
     * console session is closed, they have to override 
     * {@link #afterOnClosed(Closed, ConsoleSession)}.
     * 
     * @param event the closed event
     * @param consoleSession the web console session
     */
    @Handler
    public final void onClosed(Closed event, ConsoleSession consoleSession) {
        conletInfosByConsoleSession.remove(consoleSession);
        updateRefresh();
        afterOnClosed(event, consoleSession);
    }

    /**
     * Invoked by {@link #onClosed(Closed, ConsoleSession)} after
     * the web console session has been removed from the set of
     * tracked sessions. The default implementation does
     * nothing.
     * 
     * @param event the closed event
     * @param consoleSession the web console session
     */
    protected void afterOnClosed(Closed event, ConsoleSession consoleSession) {
        // Default is to do nothing.
    }

    /**
     * Calls {@link #doRemoveConletType()} if this component
     * is detached.
     *
     * @param event the event
     */
    @Handler
    public void onDetached(Detached event) {
        if (!equals(event.node())) {
            return;
        }
        doRemoveConletType();
    }

    /**
     * Iterates over all sessions and fires {@link DeleteConlet}
     * events for all known conlets and a {@link RemoveConletType} 
     * event.
     */
    protected void doRemoveConletType() {
        conletIdsByConsoleSession().forEach((session, conletIds) -> {
            conletIds.forEach(conletId -> {
                session.respond(
                    new DeleteConlet(conletId, RenderMode.basicModes));
            });
            session.respond(new RemoveConletType(type()));
        });
    }

    /**
     * The information tracked about web console components that are
     * used by the console. It includes the component's id and the
     * currently rendered views (only preview and view are tracked,
     * with "deletable preview" mapped to "preview").
     */
    protected static class ConletTrackingInfo {
        private final String conletId;
        private final Set<RenderMode> renderedAs;

        /**
         * Instantiates a new conlet tracking info.
         *
         * @param conletId the conlet id
         */
        public ConletTrackingInfo(String conletId) {
            this.conletId = conletId;
            renderedAs = new HashSet<>();
        }

        /**
         * Returns the conlet id.
         *
         * @return the id
         */
        public String conletId() {
            return conletId;
        }

        /**
         * The render modes current used.
         *
         * @return the render modes
         */
        public Set<RenderMode> renderedAs() {
            return renderedAs;
        }

        /**
         * Adds the given modes.
         *
         * @param modes the modes
         * @return the conlet tracking info
         */
        public ConletTrackingInfo addModes(Set<RenderMode> modes) {
            if (modes.contains(RenderMode.Preview)) {
                renderedAs.add(RenderMode.Preview);
            }
            if (modes.contains(RenderMode.View)) {
                renderedAs.add(RenderMode.View);
            }
            return this;
        }

        /**
         * Removes the given modes.
         *
         * @param modes the modes
         * @return the conlet tracking info
         */
        public ConletTrackingInfo removeModes(Set<RenderMode> modes) {
            renderedAs.removeAll(modes);
            return this;
        }

        @Override
        public int hashCode() {
            return conletId.hashCode();
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            ConletTrackingInfo other = (ConletTrackingInfo) obj;
            if (conletId == null) {
                if (other.conletId != null) {
                    return false;
                }
            } else if (!conletId.equals(other.conletId)) {
                return false;
            }
            return true;
        }
    }

    /**
     * Returns a future string providing the result
     * from reading everything from the provided reader. 
     *
     * @param request the request, used to obtain the 
     * {@link ExecutorService} service related with the request being
     * processed
     * @param contentReader the reader
     * @return the future
     */
    public Future<String> readContent(RenderConletRequestBase<?> request,
            Reader contentReader) {
        return readContent(
            request.processedBy().map(pby -> pby.executorService())
                .orElse(Components.defaultExecutorService()),
            contentReader);
    }

    /**
     * Returns a future string providing the result
     * from reading everything from the provided reader. 
     *
     * @param execSvc the executor service for reading the content
     * @param contentReader the reader
     * @return the future
     */
    public Future<String> readContent(ExecutorService execSvc,
            Reader contentReader) {
        return execSvc.submit(() -> {
            StringWriter content = new StringWriter();
            CharBuffer buffer = CharBuffer.allocate(8192);
            try (Reader rdr = new BufferedReader(contentReader)) {
                while (true) {
                    if (rdr.read(buffer) < 0) {
                        break;
                    }
                    buffer.flip();
                    content.append(buffer);
                    buffer.clear();
                }
            } catch (IOException e) {
                throw new IllegalStateException(e);
            }
            return content.toString();
        });
    }

}
